package org.sasanlabs.service.vulnerability.CSRFVulnerability;

import org.apache.commons.lang3.StringUtils;
import org.sasanlabs.internal.utility.LevelConstants;
import org.sasanlabs.internal.utility.Variant;
import org.sasanlabs.internal.utility.annotations.AttackVector;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;
import org.sasanlabs.service.exception.ServiceApplicationException;
import org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;
import org.sasanlabs.vulnerability.types.VulnerabilityType;
import org.springframework.http.HttpStatus;
import org.springframework.http.RequestEntity;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RequestParam;

import java.io.IOException;
import java.util.function.Supplier;
import java.util.regex.Pattern;
import java.util.Random;

/**
 * This class contains vulnerabilities related to CSRF.
 *
 * @author xxx
 */
@VulnerableAppRestController(
        descriptionLabel = "CSRF_VULNERABILITY",
        value = "CSRFVulnerability")
public class CSRFVulnerability {

    private static final String PTTRN_PGE = "resetpassword\\.php(\\?.*=.*)?";
    private static final String PTTRN_GET = "resetpassword\\.php\\?(.*=.*&)?pwd=.*";
    private static final String PTTRN_PST = "(.*=.*&)?pwd=.*";

    private static final String ATK_FAIL = "Password not Changed";
    private static final String ATK_SCSS = "Password changed, the attack has been successful!";

    private static final String URL_PARAM = "urlparam";
    private static final String PST_PARAM = "pstparam";
    private static final String RTK_PARAM = "rtkparam";

    private static final Random rand = new Random();

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.CSRF,
            description = "CSRF_VULNERABILITY_USER_INPUT1",
            payload = "CSRF_PAYLOAD_LEVEL_1")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_1,
            htmlTemplate = "LEVEL_1/CSRFVulnerability")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>>
    getVulnerableCSRFLvl1(@RequestParam(URL_PARAM) String rqstParam) throws IOException {
        Supplier<Boolean> validator = () -> StringUtils.isNotBlank(rqstParam);
        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                new GenericVulnerabilityResponseBean<String>(
                        (Pattern.matches(PTTRN_GET, rqstParam) && validator.get()) ? ATK_SCSS : ATK_FAIL,
                        true),
                HttpStatus.OK);
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.CSRF,
            description = "CSRF_VULNERABILITY_USER_INPUT2",
            payload = "CSRF_PAYLOAD_LEVEL_2")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_2,
            htmlTemplate = "LEVEL_2/CSRFVulnerability")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>>
    getVulnerableCSRFLvl2(
            @RequestParam(URL_PARAM) String urlParam,
            @RequestParam(PST_PARAM) String pstParam) throws IOException {
        Supplier<Boolean> validator = () -> StringUtils.isNotBlank(urlParam + pstParam);
        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                new GenericVulnerabilityResponseBean<String>((
                        Pattern.matches(PTTRN_PGE, urlParam) &&
                                Pattern.matches(PTTRN_PST, pstParam) &&
                                validator.get()) ? ATK_SCSS : ATK_FAIL,
                        true),
                HttpStatus.OK);
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.CSRF,
            description = "CSRF_VULNERABILITY_USER_INPUT3")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_3,
            htmlTemplate = "LEVEL_3/CSRFVulnerability",
            variant = Variant.SECURE)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>>
    getVulnerableCSRFLvl3(
            @RequestParam(URL_PARAM) String rqstParam,
            @RequestParam(RTK_PARAM) String rdmtoken) throws IOException {
        Supplier<Boolean> validator = () -> StringUtils.isNotBlank(rqstParam + rdmtoken);
        int livetoken = rand.nextInt(1000000);
        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                new GenericVulnerabilityResponseBean<String>(((
                        Pattern.matches(PTTRN_GET, rqstParam) &&
                                livetoken == Integer.parseInt(rdmtoken) &&
                                validator.get()) ? ATK_SCSS : ATK_FAIL)
                        + "</br> Session random token of the action: " + livetoken,
                        true),
                HttpStatus.OK);
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.CSRF,
            description = "CSRF_VULNERABILITY_USER_INPUT3")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_4,
            htmlTemplate = "LEVEL_4/CSRFVulnerability",
            variant = Variant.SECURE)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>>
    getVulnerableCSRFLvl4(
            @RequestParam(URL_PARAM) String urlParam,
            @RequestParam(PST_PARAM) String pstParam,
            @RequestParam(RTK_PARAM) String rdmtoken) throws IOException {
        Supplier<Boolean> validator = () -> StringUtils.isNotBlank(urlParam + pstParam + rdmtoken);
        int livetoken = rand.nextInt(1000000);
        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                new GenericVulnerabilityResponseBean<String>(((
                        Pattern.matches(PTTRN_PGE, urlParam) &&
                                Pattern.matches(PTTRN_PST, pstParam) &&
                                livetoken == Integer.parseInt(rdmtoken) &&
                                validator.get()) ? ATK_SCSS : ATK_FAIL)
                        + "</br> Session random token of the action: " + livetoken,
                        true),
                HttpStatus.OK);
    }
}
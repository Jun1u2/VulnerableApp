package org.sasanlabs.service.vulnerability.csrf;

import java.io.IOException;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Supplier;
import org.apache.commons.lang3.StringUtils;
import org.sasanlabs.internal.utility.LevelConstants;
import org.sasanlabs.internal.utility.Variant;
import org.sasanlabs.internal.utility.annotations.AttackVector;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;
import org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;
import org.sasanlabs.vulnerability.types.VulnerabilityType;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.util.CollectionUtils;

/**
 * This class contains vulnerabilities related to CSRF.
 *
 * @author GitHub : NMV01
 */
@VulnerableAppRestController(descriptionLabel = "CSRF_VULNERABILITY", value = "CSRFVulnerability")
public class CSRFVulnerability {

    private static final String USR_LOGIN = "id";
    private static final String USR_PASS = "pass";
    private static final String USR_NEWPASS = "newpass";
    private static final String TOKEN_PARAM = "rtkparam";
    private static final String FIXED_TOKEN = "7877864849";

    private static final String LOGIN = "mylogin";
    private String currentPassword = "mypassword";

    private Boolean userIsLoggedIn = false;
    private String secretToken = "";

    private static final SecureRandom rand = new SecureRandom();

    private String checkInputs(
            String userId, String userPassword, String newUserPassword, Boolean isSecure) {
        Supplier<Boolean> validatorId = () -> StringUtils.isNotBlank(userId + userPassword);
        Supplier<Boolean> validatorNP = () -> StringUtils.isNotBlank(newUserPassword);
        String result;
        if (validatorId.get()) {
            if (userId.equals(LOGIN) && userPassword.equals(currentPassword)) {
                userIsLoggedIn = true;
                result = "<div id=\"login\">[Logged in]</div> Hello " + userId + ".";
            } else {
                userIsLoggedIn = false;
                result = "<div id=\"logout\">[Not Logged in]</div> Wrong credentials.";
            }
        } else if (validatorNP.get()) {
            if (userIsLoggedIn && isSecure) {
                currentPassword = newUserPassword;
                result = "<div id=\"login\">[Logged in]</div> Password changed correctly.";
            } else {
                result =
                        (userIsLoggedIn
                                ? "Password change refused."
                                : "<div id=\"logout\">[Not Logged in]</div> You are not logged in. Login to change password.");
            }
        } else {
            result = "BAD INPUT !";
        }
        return result;
    }

    private String checkInputsToken(
            String usrLiveToken,
            String usrGenToken,
            String usrId,
            String usrPass,
            String usrNewPass) {
        Supplier<Boolean> validator = () -> StringUtils.isNotBlank(usrLiveToken);
        String rtn;
        if (validator.get() && usrLiveToken.equals(usrGenToken)) {
            rtn = checkInputs(usrId, usrPass, usrNewPass, true);
        } else {
            rtn = checkInputs(usrId, usrPass, usrNewPass, false);
        }
        return rtn;
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.CSRF,
            description = "CSRF_VULNERABILITY_USER_INPUT1",
            payload = "CSRF_PAYLOAD_LEVEL_1")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_1,
            htmlTemplate = "LEVEL_1/CSRFVulnerability")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerableCSRFLvl1(
            @RequestParam(USR_LOGIN) String usrId,
            @RequestParam(USR_PASS) String usrPass,
            @RequestParam(USR_NEWPASS) String usrNewPass)
            throws IOException {
        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                new GenericVulnerabilityResponseBean<String>(
                        checkInputs(usrId, usrPass, usrNewPass, true), true),
                HttpStatus.OK);
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.CSRF,
            description = "CSRF_VULNERABILITY_USER_INPUT2",
            payload = "CSRF_PAYLOAD_LEVEL_2")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_2,
            htmlTemplate = "LEVEL_2/CSRFVulnerability",
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerableCSRFLvl2(
            @RequestParam(USR_LOGIN) String usrId,
            @RequestParam(USR_PASS) String usrPass,
            @RequestParam(USR_NEWPASS) String usrNewPass)
            throws IOException {
        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                new GenericVulnerabilityResponseBean<String>(
                        checkInputs(usrId, usrPass, usrNewPass, true), true),
                HttpStatus.OK);
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.CSRF,
            description = "CSRF_VULNERABILITY_USER_INPUT1",
            payload = "CSRF_PAYLOAD_LEVEL_3")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_3,
            htmlTemplate = "LEVEL_3/CSRFVulnerability")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerableCSRFLvl3(
            @RequestParam(USR_LOGIN) String usrId,
            @RequestParam(USR_PASS) String usrPass,
            @RequestParam(USR_NEWPASS) String usrNewPass,
            @RequestParam(TOKEN_PARAM) String usrLiveToken)
            throws IOException {
        Map<String, List<String>> headers = new HashMap<>();
        headers.put("Set-Cookie", Arrays.asList(FIXED_TOKEN + "; HttpOnly; Secure"));
        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                new GenericVulnerabilityResponseBean<String>(
                        checkInputsToken(usrLiveToken, FIXED_TOKEN, usrId, usrPass, usrNewPass),
                        true),
                HttpStatus.OK);
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.CSRF,
            description = "CSRF_VULNERABILITY_USER_INPUT1",
            payload = "CSRF_PAYLOAD_LEVEL_3")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_4,
            htmlTemplate = "LEVEL_4/CSRFVulnerability",
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerableCSRFLvl3(
            @RequestParam(USR_LOGIN) String usrId,
            @RequestParam(USR_PASS) String usrPass,
            @RequestParam(USR_NEWPASS) String usrNewPass,
            @RequestParam(TOKEN_PARAM) String usrLiveToken)
            throws IOException {
        Map<String, List<String>> headers = new HashMap<>();
        headers.put("Set-Cookie", Arrays.asList(FIXED_TOKEN + "; HttpOnly; Secure"));
        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                new GenericVulnerabilityResponseBean<String>(
                        checkInputsToken(usrLiveToken, FIXED_TOKEN, usrId, usrPass, usrNewPass),
                        true),CollectionUtils.toMultiValueMap(headers),
                HttpStatus.OK);
    }


    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.CSRF,
            description = "CSRF_VULNERABILITY_USER_INPUT1",
            payload = "CSRF_PAYLOAD_LEVEL_5")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_5,
            htmlTemplate = "LEVEL_5/CSRFVulnerability",
            variant = Variant.SECURE)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerableCSRFLvl5(
            @RequestParam(USR_LOGIN) String usrId,
            @RequestParam(USR_PASS) String usrPass,
            @RequestParam(USR_NEWPASS) String usrNewPass,
            @RequestParam(TOKEN_PARAM) String usrLiveToken)
            throws IOException {
	Map<String, List<String>> headers = new HashMap<>();
        headers.put("Set-Cookie", Arrays.asList(FIXED_TOKEN + "; HttpOnly; Secure"));
        if (usrLiveToken.equals("secretrequest")) {
            secretToken = Integer.toString(rand.nextInt(1000000000));
            return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                    new GenericVulnerabilityResponseBean<String>(secretToken, true),CollectionUtils.toMultiValueMap(headers),
		    HttpStatus.OK);
        } else {
            return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                    new GenericVulnerabilityResponseBean<String>(
                            checkInputsToken(usrLiveToken, secretToken, usrId, usrPass, usrNewPass),
                            true),CollectionUtils.toMultiValueMap(headers),
                    HttpStatus.OK);
        }
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.CSRF,
            description = "CSRF_VULNERABILITY_USER_INPUT2",
            payload = "CSRF_PAYLOAD_LEVEL_5")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_6,
            htmlTemplate = "LEVEL_6/CSRFVulnerability",
            variant = Variant.SECURE,
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerableCSRFLvl6(
            @RequestParam(USR_LOGIN) String usrId,
            @RequestParam(USR_PASS) String usrPass,
            @RequestParam(USR_NEWPASS) String usrNewPass,
            @RequestParam(TOKEN_PARAM) String usrLiveToken)
            throws IOException {
	Map<String, List<String>> headers = new HashMap<>();
        headers.put("Set-Cookie", Arrays.asList(FIXED_TOKEN + "; HttpOnly; Secure"));
        if (usrLiveToken.equals("secretrequest")) {
            secretToken = Integer.toString(rand.nextInt(1000000000));
            return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                    new GenericVulnerabilityResponseBean<String>(secretToken, true), CollectionUtils.toMultiValueMap(headers),
		    HttpStatus.OK);
        } else {
            return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                    new GenericVulnerabilityResponseBean<String>(
                            checkInputsToken(usrLiveToken, secretToken, usrId, usrPass, usrNewPass),
                            true), CollectionUtils.toMultiValueMap(headers),
                    HttpStatus.OK);
        }
    }
}

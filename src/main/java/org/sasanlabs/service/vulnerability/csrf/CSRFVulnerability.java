package org.sasanlabs.service.vulnerability.csrf;

import org.apache.commons.lang3.StringUtils;
import org.sasanlabs.internal.utility.LevelConstants;
import org.sasanlabs.internal.utility.Variant;
import org.sasanlabs.internal.utility.annotations.AttackVector;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;
import org.sasanlabs.service.exception.ServiceApplicationException;
import org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;
import org.sasanlabs.vulnerability.types.VulnerabilityType;
import org.springframework.http.HttpStatus;
import org.springframework.http.RequestEntity;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;

import java.io.IOException;
import java.util.function.Supplier;
import java.util.regex.Pattern;
import java.util.Random;

/**
 * This class contains vulnerabilities related to CSRF.
 *
 * @author xxx
 */
@VulnerableAppRestController(
        descriptionLabel = "CSRF_VULNERABILITY",
        value = "CSRFVulnerability")
public class CSRFVulnerability {

    //private static final String PTTRN_PGE = "resetpassword\\.php(\\?.*=.*)?";
    //private static final String PTTRN_GET = "resetpassword\\.php\\?(.*=.*&)?pwd=.*";
    //private static final String PTTRN_PST = "(.*=.*&)?pwd=.*";

    //private static final String ATK_FAIL = "Password not Changed";
    //private static final String ATK_SCSS = "Password changed, the attack has been successful!";
    private static final String RTN_BADINPUT = "Bad input!";

    private static final String USR_LOGIN = "id";
    private static final String USR_PASS = "pass";
    private static final String USR_NEWPASS = "newpass";

    private static final String LOGIN = "mylogin";
    private String passlive = "mypassword";
    private Boolean connect = false;

    private static final String RTK_PARAM = "rtkparam";
    private static final String FIXED_TOKEN= "7877864849";
    private String scrt = "";

    private static final Random rand = new Random();

    private String checkInputs(String usrId, String usrPass, String usrNewPass, Boolean securityOk) {
        Supplier<Boolean> validatorId = () -> StringUtils.isNotBlank(usrId + usrPass);
        Supplier<Boolean> validatorNP = () -> StringUtils.isNotBlank(usrNewPass);
        String rtn;
        if (validatorId.get()) {
            if (usrId.equals(LOGIN) && usrPass.equals(passlive)){
                connect = true;
                rtn = "<div id=\"lgin\">[Logged in]</div> Hello " + usrId + ".";
            } else {
                connect = false;
                rtn = "<div id=\"lgou\">[Not Logged in]</div> Wrong credentials.";
            }
        } else if (validatorNP.get()) {
            if (connect && securityOk) {
                passlive = usrNewPass;
                rtn = "<div id=\"lgin\">[Logged in]</div> Password changed correctly.";
            } else {
                rtn =  (connect ?
                        "Password change refused." :
                        "<div id=\"lgou\">[Not Logged in]</div> You are not logged in. Login to change password.");
            }
        } else {
            rtn = "BAD INPUT !";
        }
        return rtn;
    }

    private String checkInputsToken(String usrLiveToken, String usrGenToken, String usrId, String usrPass, String usrNewPass) {
        Supplier<Boolean> validator = () -> StringUtils.isNotBlank(usrLiveToken);
        String rtn;
        if (validator.get() && usrLiveToken.equals(usrGenToken)) {
            rtn = checkInputs(usrId, usrPass, usrNewPass, true);
        } else {
            rtn = checkInputs(usrId, usrPass, usrNewPass, false);
        }
        return rtn;
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.CSRF,
            description = "CSRF_VULNERABILITY_USER_INPUT1",
            payload = "CSRF_PAYLOAD_LEVEL_1")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_1,
            htmlTemplate = "LEVEL_1/CSRFVulnerability")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>>
    getVulnerableCSRFLvl1(
            @RequestParam(USR_LOGIN) String usrId,
            @RequestParam(USR_PASS) String usrPass,
            @RequestParam(USR_NEWPASS) String usrNewPass) throws IOException {
        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                new GenericVulnerabilityResponseBean<String>(
                        checkInputs(usrId, usrPass, usrNewPass, true),
                        true),
                HttpStatus.OK);
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.CSRF,
            description = "CSRF_VULNERABILITY_USER_INPUT2",
            payload = "CSRF_PAYLOAD_LEVEL_2")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_2,
            htmlTemplate = "LEVEL_2/CSRFVulnerability",
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>>
    getVulnerableCSRFLvl2(
            @RequestParam(USR_LOGIN) String usrId,
            @RequestParam(USR_PASS) String usrPass,
            @RequestParam(USR_NEWPASS) String usrNewPass) throws IOException {
        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                new GenericVulnerabilityResponseBean<String>(
                        checkInputs(usrId, usrPass, usrNewPass, true),
                        true),
                HttpStatus.OK);
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.CSRF,
            description = "CSRF_VULNERABILITY_USER_INPUT1",
            payload = "CSRF_PAYLOAD_LEVEL_3")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_3,
            htmlTemplate = "LEVEL_3/CSRFVulnerability")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>>
    getVulnerableCSRFLvl3(
            @RequestParam(USR_LOGIN) String usrId,
            @RequestParam(USR_PASS) String usrPass,
            @RequestParam(USR_NEWPASS) String usrNewPass,
            @RequestParam(RTK_PARAM) String usrLiveToken) throws IOException {
        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                new GenericVulnerabilityResponseBean<String>(
                        checkInputsToken(
                                usrLiveToken,
                                FIXED_TOKEN,
                                usrId,
                                usrPass,
                                usrNewPass),
                        true),
                HttpStatus.OK);
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.CSRF,
            description = "CSRF_VULNERABILITY_USER_INPUT2",
            payload = "CSRF_PAYLOAD_LEVEL_3")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_4,
            htmlTemplate = "LEVEL_4/CSRFVulnerability",
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>>
    getVulnerableCSRFLvl4(
            @RequestParam(USR_LOGIN) String usrId,
            @RequestParam(USR_PASS) String usrPass,
            @RequestParam(USR_NEWPASS) String usrNewPass,
            @RequestParam(RTK_PARAM) String usrLiveToken) throws IOException {
        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                new GenericVulnerabilityResponseBean<String>(
                        checkInputsToken(
                                usrLiveToken,
                                FIXED_TOKEN,
                                usrId,
                                usrPass,
                                usrNewPass),
                        true),
                HttpStatus.OK);
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.CSRF,
            description = "CSRF_VULNERABILITY_USER_INPUT1",
            payload = "CSRF_PAYLOAD_LEVEL_5")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_5,
            htmlTemplate = "LEVEL_5/CSRFVulnerability",
            variant = Variant.SECURE)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>>
    getVulnerableCSRFLvl5(
            @RequestParam(USR_LOGIN) String usrId,
            @RequestParam(USR_PASS) String usrPass,
            @RequestParam(USR_NEWPASS) String usrNewPass,
            @RequestParam(RTK_PARAM) String usrLiveToken) throws IOException {
        if (usrLiveToken.equals("secretrequest")) {
            scrt = Integer.toString(rand.nextInt(1000000000));
            return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                    new GenericVulnerabilityResponseBean<String>(
                            scrt,
                            true),
                    HttpStatus.OK);
        } else {
            return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                    new GenericVulnerabilityResponseBean<String>(
                            checkInputsToken(
                                    usrLiveToken,
                                    scrt,
                                    usrId,
                                    usrPass,
                                    usrNewPass),
                            true),
                    HttpStatus.OK);
        }
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.CSRF,
            description = "CSRF_VULNERABILITY_USER_INPUT2",
            payload = "CSRF_PAYLOAD_LEVEL_5")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_6,
            htmlTemplate = "LEVEL_6/CSRFVulnerability",
            variant = Variant.SECURE,
            requestMethod = RequestMethod.POST)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>>
    getVulnerableCSRFLvl6(
            @RequestParam(USR_LOGIN) String usrId,
            @RequestParam(USR_PASS) String usrPass,
            @RequestParam(USR_NEWPASS) String usrNewPass,
            @RequestParam(RTK_PARAM) String usrLiveToken) throws IOException {
        if (usrLiveToken.equals("secretrequest")) {
            scrt = Integer.toString(rand.nextInt(1000000000));
            return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                    new GenericVulnerabilityResponseBean<String>(
                            scrt,
                            true),
                    HttpStatus.OK);
        } else {
            return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                    new GenericVulnerabilityResponseBean<String>(
                            checkInputsToken(
                                    usrLiveToken,
                                    scrt,
                                    usrId,
                                    usrPass,
                                    usrNewPass),
                            true),
                    HttpStatus.OK);
        }
    }
}
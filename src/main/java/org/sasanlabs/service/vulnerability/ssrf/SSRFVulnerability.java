package org.sasanlabs.service.vulnerability.ssrf;

import com.nimbusds.jose.util.StandardCharset;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.net.URLConnection;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.List;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.sasanlabs.internal.utility.LevelConstants;
import org.sasanlabs.internal.utility.Variant;
import org.sasanlabs.internal.utility.annotations.AttackVector;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;
import org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;
import org.sasanlabs.vulnerability.types.VulnerabilityType;
import org.springframework.core.io.ClassPathResource;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.util.StreamUtils;
import org.springframework.web.bind.annotation.RequestParam;

@VulnerableAppRestController(descriptionLabel = "SSRF_VULNERABILITY", value = "SSRFVulnerability")
public class SSRFVulnerability {

    private static final String IMAGE_URL = "imageurl";
    private static final String LOCALHOST_PATTERN = ".*localhost.*";
    private static final String LOCALHOST_PATTERN2 = ".*127.0.0.1.*";
    private static final transient Logger LOGGER = LogManager.getLogger(SSRFVulnerability.class);

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.SIMPLE_SSRF,
            description = "IMAGE_URL_PASSED_TO_REQUEST")
    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_1, htmlTemplate = "LEVEL_1/SSRF")
    public ResponseEntity<GenericVulnerabilityResponseBean<byte[]>> getVulnerablePayloadLevel1(
            @RequestParam(IMAGE_URL) String urlImage) {
        try {
            URL u = new URL(urlImage);
            URLConnection urlConnection = u.openConnection();
            byte[] bytes;
            try (InputStream in = urlConnection.getInputStream()) {
                bytes = StreamUtils.copyToByteArray(urlConnection.getInputStream());
            }
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>(bytes, true), HttpStatus.OK);
        } catch (Exception e) {
            LOGGER.error(
                    "Following exception occurred while opening the connection to {}", urlImage, e);
        }
        return new ResponseEntity<>(
                new GenericVulnerabilityResponseBean<>(
                        ("Failed to fetch image from URL " + urlImage)
                                .getBytes(StandardCharset.UTF_8),
                        false),
                HttpStatus.BAD_REQUEST);
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.SSRF_WITH_INPUT_FILTERS,
            description = "IMAGE_URL_PASSED_TO_REQUEST_IF_NOT_LOCALHOST")
    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_2, htmlTemplate = "LEVEL_1/SSRF")
    public ResponseEntity<GenericVulnerabilityResponseBean<byte[]>> getVulnerablePayloadLevel2(
            @RequestParam(IMAGE_URL) String urlImage) {
        try {
            if (!(Pattern.matches(LOCALHOST_PATTERN, urlImage) || Pattern.matches(LOCALHOST_PATTERN2, urlImage))) {
                URL u = new URL(urlImage);
                URLConnection urlConnection = u.openConnection();
                byte[] bytes;
                try (InputStream in = urlConnection.getInputStream()) {
                    bytes = StreamUtils.copyToByteArray(urlConnection.getInputStream());
                }
                return new ResponseEntity<>(
                        new GenericVulnerabilityResponseBean<>(bytes, true), HttpStatus.OK);
            } else {
                return new ResponseEntity<>(
                        new GenericVulnerabilityResponseBean<>(
                                ("Failed to fetch image from URL " + urlImage + ", not a valid IPv4 address")
                                        .getBytes(StandardCharset.UTF_8),
                                false),
                        HttpStatus.OK);
            }
        } catch (Exception e) {
            LOGGER.error(
                    "Following exception occurred while opening the connection to {}", urlImage, e);
        }
        return new ResponseEntity<>(
                new GenericVulnerabilityResponseBean<>(
                        ("Failed to fetch image from URL " + urlImage)
                                .getBytes(StandardCharset.UTF_8),
                        false),
                HttpStatus.OK);
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.SSRF_WITH_INPUT_FILTERS,
            description = "IMAGE_URL_PASSED_TO_REQUEST_IF_NOT_IN_THE_BLACKLIST")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_3,
            htmlTemplate = "LEVEL_1/SSRF",
            variant = Variant.SECURE)
    public ResponseEntity<GenericVulnerabilityResponseBean<byte[]>> getVulnerablePayloadLevel3(
            @RequestParam(IMAGE_URL) String urlImage) throws IOException {
        File file = new ClassPathResource("static/files/blacklist.txt").getFile();
        try (BufferedReader br = Files.newBufferedReader(Paths.get(file.getAbsolutePath()))) {
            List<String> list = br.lines().collect(Collectors.toList());
            for (String s : list) {
                if(Pattern.matches(s, urlImage)) {
                    return new ResponseEntity<>(
                            new GenericVulnerabilityResponseBean<>(
                                    ("Failed to fetch image from URL " + urlImage + ", blacklisted URL")
                                            .getBytes(StandardCharset.UTF_8),
                                    false),
                            HttpStatus.OK);
                }
            }
            URL u = new URL(urlImage);
            URLConnection urlConnection = u.openConnection();
            byte[] bytes;
            try (InputStream in = urlConnection.getInputStream()) {
                bytes = StreamUtils.copyToByteArray(urlConnection.getInputStream());
            }
            return new ResponseEntity<>(new GenericVulnerabilityResponseBean<>(bytes, true), HttpStatus.OK);
        } catch (Exception e) {
            LOGGER.error(
                    "Following exception occurred while opening the connection to {}", urlImage, e);
        }
        return new ResponseEntity<>(
                new GenericVulnerabilityResponseBean<>(
                        ("Failed to fetch image from URL " + urlImage)
                                .getBytes(StandardCharset.UTF_8),
                        false),
                HttpStatus.OK);
    }
}

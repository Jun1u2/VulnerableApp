package org.sasanlabs.service.vulnerability.ssrf;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.FileNotFoundException;
import java.io.File;
import java.io.Reader;
import java.net.URL;
import java.net.MalformedURLException;
import java.net.URISyntaxException;
import java.net.URLConnection;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.regex.Pattern;

import org.sasanlabs.internal.utility.LevelConstants;
import org.sasanlabs.internal.utility.Variant;
import org.sasanlabs.internal.utility.annotations.AttackVector;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;
import org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;
import org.sasanlabs.vulnerability.types.VulnerabilityType;
import org.springframework.core.io.ClassPathResource;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RequestParam;

@VulnerableAppRestController(descriptionLabel = "SSRF_VULNERABILITY", value = "SSRFVulnerability")
public class SSRFVulnerability {

    private static final String FILE_URL = "fileurl";
    private static final String FILE_PATH = "static/files/SSRF.txt";
    private static final String FILE_NAME = "SSRF.txt";
    private static final String FILE_PROTOCOL = "file://";
    private static final String LOCALHOST_PATTERN = ".*localhost.*";
    private static final String[] LOCALHOST_VARIANTS_PATTERN = {".*127.0.0.1.*", ".*127.1.*", ".*127.0.1.*"};
    private static final String[] URL_WHITE_LIST = { "https://github.com/SasanLabs/",
            "https://github.com/SasanLabs/VulnerableApp", "https://github.com/SasanLabs/owasp-zap-jwt-addon",
            "https://github.com/SasanLabs/owasp-zap-fileupload-addon", "https://github.com/SasanLabs/VulnerableApp-php",
            "https://github.com/SasanLabs/VulnerableApp-jsp"};

    boolean isUrlValid(String url) {
        try {
            URL obj = new URL(url);
            obj.toURI();
            return true;
        } catch (MalformedURLException | URISyntaxException e) {
            return false;
        }
    }

    StringBuilder writeResult(Reader in) throws IOException {
        StringBuilder content = new StringBuilder();
        BufferedReader bufferedReader = new BufferedReader(in);
        String line;
        while ((line = bufferedReader.readLine()) != null) {
            content.append(line).append("\n");
        }
        bufferedReader.close();
        return content;
    }

    ResponseEntity<GenericVulnerabilityResponseBean<StringBuilder>> getGenericVulnerabilityResponseWhenURL(
            @RequestParam(FILE_URL) String url) throws IOException {
        URL u = new URL(url);
        URLConnection urlConnection = u.openConnection();
        try {
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>(
                            writeResult(new InputStreamReader(urlConnection.getInputStream())), true),
                    HttpStatus.OK);
        } catch (FileNotFoundException e) {
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>(new StringBuilder("File not present."),
                            false),
                    HttpStatus.OK);
        }
    }

    ResponseEntity<GenericVulnerabilityResponseBean<StringBuilder>> getGenericVulnerabilityResponseWhenFileName(
            @RequestParam(FILE_URL) String url) throws IOException {
        if (url.equals(FILE_NAME)) {
            File file = new ClassPathResource(FILE_PATH).getFile();
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>(writeResult(
                            Files.newBufferedReader(Paths.get(file.getAbsolutePath()))),
                            true), HttpStatus.OK);
        } else {
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>(new StringBuilder("File not present."),
                            false),
                    HttpStatus.OK);
        }
    }

    private ResponseEntity<GenericVulnerabilityResponseBean<StringBuilder>> getGenericVulnerabilityResponseWhenFilters(
            @RequestParam(FILE_URL) String url) throws IOException {
        if (!url.startsWith(FILE_PROTOCOL) && !Pattern.matches(LOCALHOST_PATTERN, url)) {
            return getGenericVulnerabilityResponseWhenURL(url);
        } else {
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>(url.startsWith(FILE_PROTOCOL) ?
                            new StringBuilder("file:// protocol is not allowed") :
                            new StringBuilder("localhost is not allowed"),
                            false),
                    HttpStatus.OK);
        }
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.SIMPLE_SSRF,
            description = "FILE_URL_WITHOUT_CHECK",
            payload = "SSRF_PAYLOAD_LEVEL_1")
    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_1, htmlTemplate = "LEVEL_1/SSRF")
    public ResponseEntity<GenericVulnerabilityResponseBean<StringBuilder>> getVulnerablePayloadLevel1(
            @RequestParam(FILE_URL) String url) throws IOException, URISyntaxException {
        if (isUrlValid(url)) {
            return getGenericVulnerabilityResponseWhenURL(url);
        } else {
            return getGenericVulnerabilityResponseWhenFileName(url);
        }
    }


    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.SSRF_WITH_INPUT_FILTERS,
            description = "FILE_URL_IF_NOT_FILE_PROTOCOL",
            payload = "SSRF_PAYLOAD_LEVEL_2")
    @VulnerableAppRequestMapping(value = LevelConstants.LEVEL_2, htmlTemplate = "LEVEL_1/SSRF")
    public ResponseEntity<GenericVulnerabilityResponseBean<StringBuilder>> getVulnerablePayloadLevel2(
            @RequestParam(FILE_URL) String url) throws IOException, URISyntaxException {
        if (isUrlValid(url)) {
            if (!url.startsWith(FILE_PROTOCOL)) {
                return getGenericVulnerabilityResponseWhenURL(url);
            } else {
                return new ResponseEntity<>(
                        new GenericVulnerabilityResponseBean<>(new StringBuilder("file:// protocol is not allowed"),
                                false),
                        HttpStatus.OK);
            }
        } else {
            return getGenericVulnerabilityResponseWhenFileName(url);
        }
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.SSRF_WITH_INPUT_FILTERS,
            description = "FILE_URL_IF_NOT_FILE_PROTOCOL_AND_LOCALHOST",
            payload = "SSRF_PAYLOAD_LEVEL_3")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_3,
            htmlTemplate = "LEVEL_1/SSRF")
    public ResponseEntity<GenericVulnerabilityResponseBean<StringBuilder>> getVulnerablePayloadLevel3(
            @RequestParam(FILE_URL) String url) throws IOException {
        if (isUrlValid(url)) {
            return getGenericVulnerabilityResponseWhenFilters(url);
        } else {
            return getGenericVulnerabilityResponseWhenFileName(url);
        }
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.SSRF_WITH_INPUT_FILTERS,
            description = "FILE_URL_IF_NOT_FILE_PROTOCOL_AND_LOCALHOST_AND_VARIANTS",
            payload = "SSRF_PAYLOAD_LEVEL_4")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_4,
            htmlTemplate = "LEVEL_1/SSRF")
    public ResponseEntity<GenericVulnerabilityResponseBean<StringBuilder>> getVulnerablePayloadLevel4(
            @RequestParam(FILE_URL) String url) throws IOException {
        if (isUrlValid(url)) {
            for (String variant : LOCALHOST_VARIANTS_PATTERN) {
                if (Pattern.matches(variant, url)) {
                    return new ResponseEntity<>(
                            new GenericVulnerabilityResponseBean<>(
                                    new StringBuilder("Variants of localhost are not allowed"),
                                    false),
                            HttpStatus.OK);
                }
            }
            return getGenericVulnerabilityResponseWhenFilters(url);
        } else {
            return getGenericVulnerabilityResponseWhenFileName(url);
        }
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.SSRF_WHITE_LIST,
            description = "FILE_URL_IF_IN_THE_WHITELIST")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_5,
            htmlTemplate = "LEVEL_1/SSRF",
            variant = Variant.SECURE)
    public ResponseEntity<GenericVulnerabilityResponseBean<StringBuilder>> getVulnerablePayloadLevel5(
            @RequestParam(FILE_URL) String url) throws IOException {
        if (isUrlValid(url)) {
            if (!Arrays.asList(URL_WHITE_LIST).contains(url)) {
                return new ResponseEntity<>(
                        new GenericVulnerabilityResponseBean<>(
                                new StringBuilder("URL not part of the White List"),
                                false),
                        HttpStatus.OK);
            }
            return getGenericVulnerabilityResponseWhenURL(url);
        } else {
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>(
                            new StringBuilder("URL not valid"),
                            false),
                    HttpStatus.OK);
        }
    }
}
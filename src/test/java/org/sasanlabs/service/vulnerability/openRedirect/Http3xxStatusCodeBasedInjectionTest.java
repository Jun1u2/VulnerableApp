package org.sasanlabs.service.vulnerability.openRedirect;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.springframework.http.*;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.HashMap;

class Http3xxStatusCodeBasedInjectionTest {
    private Http3xxStatusCodeBasedInjection http3xxStatusCodeBasedInjection;
    private static final String LOCATION_HEADER_KEY = "Location";

    @BeforeEach
    void setUp() {
        http3xxStatusCodeBasedInjection = Mockito.spy(new Http3xxStatusCodeBasedInjection());
    }

    @Test
    @DisplayName("Level 1- test that returnTo query parameter's value is directly added to the Location header")
    void test_That_ReturnToQueryParameterValue_IsAddedToLocationHeader_Level1() {
        String redirectUrl = "https://www.malicious.com";
        ResponseEntity<?> responseEntity =
                http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel1(redirectUrl);
        assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY).contains("https://www.malicious.com")).isTrue();
        assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.FOUND);
        verify(http3xxStatusCodeBasedInjection, times(1)).getVulnerablePayloadLevel1("https://www.malicious.com");
    }

    private void assertStatusAndValidate(ResponseEntity<?> responseEntity, String url) {

    }

    @Test
    @DisplayName("Level 2- test that the returnTo query parameter's value is not added to the Location header when it starts http")
    void test_That_ReturnToQueryParameterValue_IsNotAddedToLocationHeader_WhenItStartsWith_Http_Level2() {
        try{
            String redirectUrl = "http://www.malicious.com";
            RequestEntity<String> requestEntity = new RequestEntity<>(HttpMethod.GET, new URI("https://somedomain.com?returnTo=http://www.malicious.com"));
            ResponseEntity<?> responseEntity = http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel2(requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY)).isEqualTo(null);
            verify(http3xxStatusCodeBasedInjection, times(1)).getVulnerablePayloadLevel2(requestEntity,"http://www.malicious.com");
        }

        catch (URISyntaxException | MalformedURLException exception){
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName("Level 2- test that the returnTo query parameter's value is not added to the Location header when it starts https")
    void test_That_ReturnToQueryParameterValue_IsNotAddedToLocationHeader_WhenItStartsWith_Https_Level2() {
        try{
            String redirectUrl = "https://www.malicious.com";
            RequestEntity<String> requestEntity = new RequestEntity<>(HttpMethod.GET, new URI("https://somedomain.com?returnTo=https://www.malicious.com"));
            ResponseEntity<?> responseEntity = http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel2(requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY)).isEqualTo(null);
            verify(http3xxStatusCodeBasedInjection, times(1)).getVulnerablePayloadLevel2(requestEntity,"https://www.malicious.com");
        }

        catch (URISyntaxException | MalformedURLException exception){
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName("Level 2- test that the returnTo query parameter's value is not added to the Location header when it starts www")
    void test_That_ReturnToQueryParameterValue_IsNotAddedToLocationHeader_WhenItStarts_WWW_Level2() {
        try{
            String redirectUrl = "www.malicious.com";
            RequestEntity<String> requestEntity = new RequestEntity<>(HttpMethod.GET, new URI("https://somedomain.com?returnTo=www.malicious.com"));
            ResponseEntity<?> responseEntity = http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel2(requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY)).isEqualTo(null);
            verify(http3xxStatusCodeBasedInjection, times(1)).getVulnerablePayloadLevel2(requestEntity,"www.malicious.com");
        }

        catch (URISyntaxException | MalformedURLException exception){
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName("Level 2- test that the returnTo query parameter's value is directly added to the Location header when it does not start with http, https or www")
    void test_That_ReturnToQueryParameterValue_IsAddedToLocationHeader_WhenItDoesNotStartWith_Http_Https_Or_WWW_Level2() {
        try{
            String redirectUrl = "ftp://ftp.dlptest.com/";
            RequestEntity<String> requestEntity = new RequestEntity<>(HttpMethod.GET, new URI("https://somedomain.com:8080?returnTo=ftp://ftp.dlptest.com/"));
            ResponseEntity<?> responseEntity = http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel2(requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.FOUND);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY)).contains("ftp://ftp.dlptest.com/");
            verify(http3xxStatusCodeBasedInjection, times(1)).getVulnerablePayloadLevel2(requestEntity,"ftp://ftp.dlptest.com/");
        }

        catch (URISyntaxException | MalformedURLException exception){
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName("Level 2- test that the returnTo query parameter's value is directly added to the Location header if it is the same as the application domain")
    void test_That_ReturnToQueryParameterValue_IsAddedToLocationHeader_WhenItIsSameAs_ApplicationDomain_Level2() {
        try{
            String redirectUrl = "somedomain.com";
            RequestEntity<String> requestEntity = new RequestEntity<>(HttpMethod.GET, new URI("https://somedomain.com?returnTo=somedomain.com"));
            ResponseEntity<?> responseEntity = http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel2(requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.FOUND);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY)).contains("somedomain.com");
            verify(http3xxStatusCodeBasedInjection, times(1)).getVulnerablePayloadLevel2(requestEntity,"somedomain.com");
        }

        catch (URISyntaxException | MalformedURLException exception){
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName("Level 3- test that the returnTo query parameter's value is not added to the Location header when it starts http")
    void test_That_ReturnToQueryParameterValue_IsNotAddedToLocationHeader_WhenItStartsWith_Http_Level3(){
        try{
            String redirectUrl = "http://www.malicious.com";
            RequestEntity<String> requestEntity = new RequestEntity<>(HttpMethod.GET, new URI("https://somedomain.com?returnTo=http://www.malicious.com"));
            ResponseEntity<?> responseEntity = http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel3(requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY)).isEqualTo(null);
            verify(http3xxStatusCodeBasedInjection, times(1)).getVulnerablePayloadLevel3(requestEntity,"http://www.malicious.com");
        }

        catch (URISyntaxException | MalformedURLException exception){
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName("Level 3- test that the returnTo query parameter's value is not added to the Location header when it starts https")
    void test_That_ReturnToQueryParameterValue_IsNotAddedToLocationHeader_WhenItStartsWith_Https_Level3(){
        try{
            String redirectUrl = "https://www.malicious.com";
            RequestEntity<String> requestEntity = new RequestEntity<>(HttpMethod.GET, new URI("https://somedomain.com?returnTo=https://www.malicious.com"));
            ResponseEntity<?> responseEntity = http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel3(requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY)).isEqualTo(null);
            verify(http3xxStatusCodeBasedInjection, times(1)).getVulnerablePayloadLevel3(requestEntity,"https://www.malicious.com");
        }

        catch (URISyntaxException | MalformedURLException exception){
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName("Level 3- test that the returnTo query parameter's value is not added to the Location header when it starts double slashes")
    void test_That_ReturnToQueryParameterValue_IsNotAddedToLocationHeader_WhenItStartsWith_DoubleSlashes_Level3(){
        try{
            String redirectUrl = "//www.malicious.com";
            RequestEntity<String> requestEntity = new RequestEntity<>(HttpMethod.GET, new URI("https://somedomain.com?returnTo=//www.malicious.com"));
            ResponseEntity<?> responseEntity = http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel3(requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY)).isEqualTo(null);
            verify(http3xxStatusCodeBasedInjection, times(1)).getVulnerablePayloadLevel3(requestEntity,"//www.malicious.com");
        }

        catch (URISyntaxException | MalformedURLException exception){
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName("Level 3- test that the returnTo query parameter's value is not added to the Location header when it starts www")
    void test_That_ReturnToQueryParameterValue_IsNotAddedToLocationHeader_WhenItStartsWith_WWW_Level3(){
        try{
            String redirectUrl = "www.malicious.com";
            RequestEntity<String> requestEntity = new RequestEntity<>(HttpMethod.GET, new URI("https://somedomain.com?returnTo=www.malicious.com"));
            ResponseEntity<?> responseEntity = http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel3(requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY)).isEqualTo(null);
            verify(http3xxStatusCodeBasedInjection, times(1)).getVulnerablePayloadLevel3(requestEntity,"www.malicious.com");
        }

        catch (URISyntaxException | MalformedURLException exception){
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName("Level 3- test that the returnTo query parameter's value is directly added to the Location header when it does not start with http, https, // or www")
    void test_That_ReturnToQueryParameterValue_IsAddedToLocationHeader_WhenItDoesNotStartWith_Http_Https_DoubleSlashes_Or_WWW_Level3() {
        try{
            String redirectUrl = "/%09/localdomain.pw";
            RequestEntity<String> requestEntity = new RequestEntity<>(HttpMethod.GET, new URI("https://somedomain.com:8080?returnTo=/%09/localdomain.pw"));
            ResponseEntity<?> responseEntity = http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel2(requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.FOUND);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY)).contains("/%09/localdomain.pw");
            verify(http3xxStatusCodeBasedInjection, times(1)).getVulnerablePayloadLevel2(requestEntity,"/%09/localdomain.pw");
        }

        catch (URISyntaxException | MalformedURLException exception){
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName("Level 3- test that the returnTo query parameter's value is directly added to the Location header if it is the same as the application domain")
    void test_That_ReturnToQueryParameterValue_IsAddedToLocationHeader_WhenItIsSameAs_ApplicationDomain_Level3() {
        try{
            String redirectUrl = "somedomain.com";
            RequestEntity<String> requestEntity = new RequestEntity<>(HttpMethod.GET, new URI("https://somedomain.com?returnTo=somedomain.com"));
            ResponseEntity<?> responseEntity = http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel3(requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.FOUND);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY)).contains("somedomain.com");
            verify(http3xxStatusCodeBasedInjection, times(1)).getVulnerablePayloadLevel3(requestEntity,"somedomain.com");
        }

        catch (URISyntaxException | MalformedURLException exception){
            exception.printStackTrace();
        }
    }

    @Test
    void getVulnerablePayloadLevel4() {}

    @Test
    void getVulnerablePayloadLevel5() {}

    @Test
    void getVulnerablePayloadLevel6() {}

    @Test
    void getVulnerablePayloadLevel7() {}

    @Test
    void getVulnerablePayloadLevel8() {}
}

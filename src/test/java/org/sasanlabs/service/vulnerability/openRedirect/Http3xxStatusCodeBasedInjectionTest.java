package org.sasanlabs.service.vulnerability.openRedirect;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;

import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.springframework.http.*;

class Http3xxStatusCodeBasedInjectionTest {
    private Http3xxStatusCodeBasedInjection http3xxStatusCodeBasedInjection;
    private static final String LOCATION_HEADER_KEY = "Location";

    @BeforeEach
    void setUp() {
        http3xxStatusCodeBasedInjection = Mockito.spy(new Http3xxStatusCodeBasedInjection());
    }

    @Test
    @DisplayName(
            "Level 1- test that returnTo query parameter's value is directly added to the Location header")
    void test_That_ReturnToQueryParameterValue_IsAddedToLocationHeader_Level1() {
        String redirectUrl = "https://www.malicious.com";
        ResponseEntity<?> responseEntity =
                http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel1(redirectUrl);
        assertThat(
                        responseEntity
                                .getHeaders()
                                .get(LOCATION_HEADER_KEY)
                                .contains("https://www.malicious.com"))
                .isTrue();
        assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.FOUND);
        verify(http3xxStatusCodeBasedInjection, times(1))
                .getVulnerablePayloadLevel1("https://www.malicious.com");
    }

    @Test
    @DisplayName(
            "Level 2- test that the returnTo query parameter's value is not added to the Location header when it starts with http")
    void
            test_That_ReturnToQueryParameterValue_IsNotAddedToLocationHeader_WhenItStartsWith_Http_Level2() {
        try {
            String redirectUrl = "http://www.malicious.com";
            RequestEntity<String> requestEntity =
                    new RequestEntity<>(
                            HttpMethod.GET,
                            new URI("https://somedomain.com?returnTo=http://www.malicious.com"));
            ResponseEntity<?> responseEntity =
                    http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel2(
                            requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY)).isEqualTo(null);
            verify(http3xxStatusCodeBasedInjection, times(1))
                    .getVulnerablePayloadLevel2(requestEntity, "http://www.malicious.com");
        } catch (URISyntaxException | MalformedURLException exception) {
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName(
            "Level 2- test that the returnTo query parameter's value is not added to the Location header when it starts with https")
    void
            test_That_ReturnToQueryParameterValue_IsNotAddedToLocationHeader_WhenItStartsWith_Https_Level2() {
        try {
            String redirectUrl = "https://www.malicious.com";
            RequestEntity<String> requestEntity =
                    new RequestEntity<>(
                            HttpMethod.GET,
                            new URI("https://somedomain.com?returnTo=https://www.malicious.com"));
            ResponseEntity<?> responseEntity =
                    http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel2(
                            requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY)).isEqualTo(null);
            verify(http3xxStatusCodeBasedInjection, times(1))
                    .getVulnerablePayloadLevel2(requestEntity, "https://www.malicious.com");
        } catch (URISyntaxException | MalformedURLException exception) {
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName(
            "Level 2- test that the returnTo query parameter's value is not added to the Location header when it starts with www")
    void
            test_That_ReturnToQueryParameterValue_IsNotAddedToLocationHeader_WhenItStarts_WWW_Level2() {
        try {
            String redirectUrl = "www.malicious.com";
            RequestEntity<String> requestEntity =
                    new RequestEntity<>(
                            HttpMethod.GET,
                            new URI("https://somedomain.com?returnTo=www.malicious.com"));
            ResponseEntity<?> responseEntity =
                    http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel2(
                            requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY)).isEqualTo(null);
            verify(http3xxStatusCodeBasedInjection, times(1))
                    .getVulnerablePayloadLevel2(requestEntity, "www.malicious.com");
        } catch (URISyntaxException | MalformedURLException exception) {
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName(
            "Level 2- test that the returnTo query parameter's value is directly added to the Location header when it does not start with http, https or www")
    void
            test_That_ReturnToQueryParameterValue_IsAddedToLocationHeader_WhenItDoesNotStartWith_Http_Https_Or_WWW_Level2() {
        try {
            String redirectUrl = "ftp://ftp.dlptest.com/";
            RequestEntity<String> requestEntity =
                    new RequestEntity<>(
                            HttpMethod.GET,
                            new URI("https://somedomain.com:8080?returnTo=ftp://ftp.dlptest.com/"));
            ResponseEntity<?> responseEntity =
                    http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel2(
                            requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.FOUND);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY))
                    .contains("ftp://ftp.dlptest.com/");
            verify(http3xxStatusCodeBasedInjection, times(1))
                    .getVulnerablePayloadLevel2(requestEntity, "ftp://ftp.dlptest.com/");
        } catch (URISyntaxException | MalformedURLException exception) {
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName(
            "Level 2- test that the returnTo query parameter's value is directly added to the Location header when it is the same as the application domain")
    void
            test_That_ReturnToQueryParameterValue_IsAddedToLocationHeader_WhenItIsSameAs_ApplicationDomain_Level2() {
        try {
            String redirectUrl = "somedomain.com";
            RequestEntity<String> requestEntity =
                    new RequestEntity<>(
                            HttpMethod.GET,
                            new URI("https://somedomain.com?returnTo=somedomain.com"));
            ResponseEntity<?> responseEntity =
                    http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel2(
                            requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.FOUND);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY))
                    .contains("somedomain.com");
            verify(http3xxStatusCodeBasedInjection, times(1))
                    .getVulnerablePayloadLevel2(requestEntity, "somedomain.com");
        } catch (URISyntaxException | MalformedURLException exception) {
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName(
            "Level 3- test that the returnTo query parameter's value is not added to the Location header when it starts with http")
    void
            test_That_ReturnToQueryParameterValue_IsNotAddedToLocationHeader_WhenItStartsWith_Http_Level3() {
        try {
            String redirectUrl = "http://www.malicious.com";
            RequestEntity<String> requestEntity =
                    new RequestEntity<>(
                            HttpMethod.GET,
                            new URI("https://somedomain.com?returnTo=http://www.malicious.com"));
            ResponseEntity<?> responseEntity =
                    http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel3(
                            requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY)).isEqualTo(null);
            verify(http3xxStatusCodeBasedInjection, times(1))
                    .getVulnerablePayloadLevel3(requestEntity, "http://www.malicious.com");
        } catch (URISyntaxException | MalformedURLException exception) {
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName(
            "Level 3- test that the returnTo query parameter's value is not added to the Location header when it starts with https")
    void
            test_That_ReturnToQueryParameterValue_IsNotAddedToLocationHeader_WhenItStartsWith_Https_Level3() {
        try {
            String redirectUrl = "https://www.malicious.com";
            RequestEntity<String> requestEntity =
                    new RequestEntity<>(
                            HttpMethod.GET,
                            new URI("https://somedomain.com?returnTo=https://www.malicious.com"));
            ResponseEntity<?> responseEntity =
                    http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel3(
                            requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY)).isEqualTo(null);
            verify(http3xxStatusCodeBasedInjection, times(1))
                    .getVulnerablePayloadLevel3(requestEntity, "https://www.malicious.com");
        } catch (URISyntaxException | MalformedURLException exception) {
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName(
            "Level 3- test that the returnTo query parameter's value is not added to the Location header when it starts with double slashes")
    void
            test_That_ReturnToQueryParameterValue_IsNotAddedToLocationHeader_WhenItStartsWith_DoubleSlashes_Level3() {
        try {
            String redirectUrl = "//www.malicious.com";
            RequestEntity<String> requestEntity =
                    new RequestEntity<>(
                            HttpMethod.GET,
                            new URI("https://somedomain.com?returnTo=//www.malicious.com"));
            ResponseEntity<?> responseEntity =
                    http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel3(
                            requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY)).isEqualTo(null);
            verify(http3xxStatusCodeBasedInjection, times(1))
                    .getVulnerablePayloadLevel3(requestEntity, "//www.malicious.com");
        } catch (URISyntaxException | MalformedURLException exception) {
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName(
            "Level 3- test that the returnTo query parameter's value is not added to the Location header when it starts with www")
    void
            test_That_ReturnToQueryParameterValue_IsNotAddedToLocationHeader_WhenItStartsWith_WWW_Level3() {
        try {
            String redirectUrl = "www.malicious.com";
            RequestEntity<String> requestEntity =
                    new RequestEntity<>(
                            HttpMethod.GET,
                            new URI("https://somedomain.com?returnTo=www.malicious.com"));
            ResponseEntity<?> responseEntity =
                    http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel3(
                            requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY)).isEqualTo(null);
            verify(http3xxStatusCodeBasedInjection, times(1))
                    .getVulnerablePayloadLevel3(requestEntity, "www.malicious.com");
        } catch (URISyntaxException | MalformedURLException exception) {
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName(
            "Level 3- test that the returnTo query parameter's value is directly added to the Location header when it does not start with http, https, // or www")
    void
            test_That_ReturnToQueryParameterValue_IsAddedToLocationHeader_WhenItDoesNotStartWith_Http_Https_DoubleSlashes_Or_WWW_Level3() {
        try {
            String redirectUrl = "/%09/localdomain.pw";
            RequestEntity<String> requestEntity =
                    new RequestEntity<>(
                            HttpMethod.GET,
                            new URI("https://somedomain.com:8080?returnTo=/%09/localdomain.pw"));
            ResponseEntity<?> responseEntity =
                    http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel3(
                            requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.FOUND);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY))
                    .contains("/%09/localdomain.pw");
            verify(http3xxStatusCodeBasedInjection, times(1))
                    .getVulnerablePayloadLevel3(requestEntity, "/%09/localdomain.pw");
        } catch (URISyntaxException | MalformedURLException exception) {
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName(
            "Level 3- test that the returnTo query parameter's value is directly added to the Location header when it is the same as the application domain")
    void
            test_That_ReturnToQueryParameterValue_IsAddedToLocationHeader_WhenItIsSameAs_ApplicationDomain_Level3() {
        try {
            String redirectUrl = "somedomain.com";
            RequestEntity<String> requestEntity =
                    new RequestEntity<>(
                            HttpMethod.GET,
                            new URI("https://somedomain.com?returnTo=somedomain.com"));
            ResponseEntity<?> responseEntity =
                    http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel3(
                            requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.FOUND);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY))
                    .contains("somedomain.com");
            verify(http3xxStatusCodeBasedInjection, times(1))
                    .getVulnerablePayloadLevel3(requestEntity, "somedomain.com");
        } catch (URISyntaxException | MalformedURLException exception) {
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName(
            "Level 4- test that the returnTo query parameter's value is not added to the Location header when it starts with http")
    void
            test_That_ReturnToQueryParameterValue_IsNotAddedToLocationHeader_WhenItStartsWith_Http_Level4() {
        try {
            String redirectUrl = "http://www.malicious.com";
            RequestEntity<String> requestEntity =
                    new RequestEntity<>(
                            HttpMethod.GET,
                            new URI("https://somedomain.com?returnTo=http://www.malicious.com"));
            ResponseEntity<?> responseEntity =
                    http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel4(
                            requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY)).isEqualTo(null);
            verify(http3xxStatusCodeBasedInjection, times(1))
                    .getVulnerablePayloadLevel4(requestEntity, "http://www.malicious.com");
        } catch (URISyntaxException | MalformedURLException exception) {
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName(
            "Level 4- test that the returnTo query parameter's value is not added to the Location header when it starts with https")
    void
            test_That_ReturnToQueryParameterValue_IsNotAddedToLocationHeader_WhenItStartsWith_Https_Level4() {
        try {
            String redirectUrl = "https://www.malicious.com";
            RequestEntity<String> requestEntity =
                    new RequestEntity<>(
                            HttpMethod.GET,
                            new URI("https://somedomain.com?returnTo=https://www.malicious.com"));
            ResponseEntity<?> responseEntity =
                    http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel4(
                            requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY)).isEqualTo(null);
            verify(http3xxStatusCodeBasedInjection, times(1))
                    .getVulnerablePayloadLevel4(requestEntity, "https://www.malicious.com");
        } catch (URISyntaxException | MalformedURLException exception) {
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName(
            "Level 4- test that the returnTo query parameter's value is not added to the Location header when it starts with double slashes")
    void
            test_That_ReturnToQueryParameterValue_IsNotAddedToLocationHeader_WhenItStartsWith_DoubleSlashes_Level4() {
        try {
            String redirectUrl = "//www.malicious.com";
            RequestEntity<String> requestEntity =
                    new RequestEntity<>(
                            HttpMethod.GET,
                            new URI("https://somedomain.com?returnTo=//www.malicious.com"));
            ResponseEntity<?> responseEntity =
                    http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel4(
                            requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY)).isEqualTo(null);
            verify(http3xxStatusCodeBasedInjection, times(1))
                    .getVulnerablePayloadLevel4(requestEntity, "//www.malicious.com");
        } catch (URISyntaxException | MalformedURLException exception) {
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName(
            "Level 4- test that the returnTo query parameter's value is not added to the Location header when it starts with www")
    void
            test_That_ReturnToQueryParameterValue_IsNotAddedToLocationHeader_WhenItStartsWith_WWW_Level4() {
        try {
            String redirectUrl = "www.malicious.com";
            RequestEntity<String> requestEntity =
                    new RequestEntity<>(
                            HttpMethod.GET,
                            new URI("https://somedomain.com?returnTo=www.malicious.com"));
            ResponseEntity<?> responseEntity =
                    http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel4(
                            requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY)).isEqualTo(null);
            verify(http3xxStatusCodeBasedInjection, times(1))
                    .getVulnerablePayloadLevel4(requestEntity, "www.malicious.com");
        } catch (URISyntaxException | MalformedURLException exception) {
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName(
            "Level 4- test that the returnTo query parameter's value is not added to the Location header when it starts with a null byte character")
    void
            test_That_ReturnToQueryParameterValue_IsNotAddedToLocationHeader_WhenItStartsWith_Null_Byte_Character_Level4() {
        try {
            String redirectUrl = (char) 0 + "/localdomain.pw";
            RequestEntity<String> requestEntity =
                    new RequestEntity<>(
                            HttpMethod.GET,
                            new URI(
                                    "https://somedomain.com?returnTo="
                                            + (char) 0
                                            + "/localdomain.pw"));
            ResponseEntity<?> responseEntity =
                    http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel4(
                            requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY)).isEqualTo(null);
            verify(http3xxStatusCodeBasedInjection, times(1))
                    .getVulnerablePayloadLevel4(requestEntity, (char) 0 + "/localdomain.pw");
        } catch (URISyntaxException | MalformedURLException exception) {
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName(
            "Level 4- test that the returnTo query parameter's value is directly added to the Location header when it does not start with http, https, //, null byte character or www")
    void
            test_That_ReturnToQueryParameterValue_IsAddedToLocationHeader_WhenItDoesNotStartWith_Http_Https_DoubleSlashes_Null_Byte_Character_Or_WWW_Level4() {
        try {
            String redirectUrl = "/%09/localdomain.pw";
            RequestEntity<String> requestEntity =
                    new RequestEntity<>(
                            HttpMethod.GET,
                            new URI("https://somedomain.com:8080?returnTo=/%09/localdomain.pw"));
            ResponseEntity<?> responseEntity =
                    http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel4(
                            requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.FOUND);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY))
                    .contains("/%09/localdomain.pw");
            verify(http3xxStatusCodeBasedInjection, times(1))
                    .getVulnerablePayloadLevel4(requestEntity, "/%09/localdomain.pw");
        } catch (URISyntaxException | MalformedURLException exception) {
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName(
            "Level 4- test that the returnTo query parameter's value is directly added to the Location header when it is the same as the application domain")
    void
            test_That_ReturnToQueryParameterValue_IsAddedToLocationHeader_WhenItIsSameAs_ApplicationDomain_Level4() {
        try {
            String redirectUrl = "somedomain.com";
            RequestEntity<String> requestEntity =
                    new RequestEntity<>(
                            HttpMethod.GET,
                            new URI("https://somedomain.com?returnTo=somedomain.com"));
            ResponseEntity<?> responseEntity =
                    http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel4(
                            requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.FOUND);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY))
                    .contains("somedomain.com");
            verify(http3xxStatusCodeBasedInjection, times(1))
                    .getVulnerablePayloadLevel4(requestEntity, "somedomain.com");
        } catch (URISyntaxException | MalformedURLException exception) {
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName(
            "Level 5- test that the returnTo query parameter's value is not added to the Location header when it starts with Https")
    void
            test_That_ReturnToQueryParameterValue_IsNotAddedToLocationHeader_WhenItStartsWith_Https_Level5() {
        try {
            String redirectUrl = "https://www.somedomain.com";
            RequestEntity<String> requestEntity =
                    new RequestEntity<>(
                            HttpMethod.GET,
                            new URI("https://somedomain.com?returnTo=https://www.somedomain.com"));
            ResponseEntity<?> responseEntity =
                    http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel5(
                            requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY)).isEqualTo(null);
            verify(http3xxStatusCodeBasedInjection, times(1))
                    .getVulnerablePayloadLevel5(requestEntity, "https://www.somedomain.com");
        } catch (URISyntaxException | MalformedURLException exception) {
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName(
            "Level 5- test that the returnTo query parameter's value is not added to the Location header when it starts with Http")
    void
            test_That_ReturnToQueryParameterValue_IsNotAddedToLocationHeader_WhenItStartsWith_Http_Level5() {
        try {
            String redirectUrl = "http://www.somedomain.com";
            RequestEntity<String> requestEntity =
                    new RequestEntity<>(
                            HttpMethod.GET,
                            new URI("https://somedomain.com?returnTo=http://www.somedomain.com"));
            ResponseEntity<?> responseEntity =
                    http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel5(
                            requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY)).isEqualTo(null);
            verify(http3xxStatusCodeBasedInjection, times(1))
                    .getVulnerablePayloadLevel5(requestEntity, "http://www.somedomain.com");
        } catch (URISyntaxException | MalformedURLException exception) {
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName(
            "Level 5- test that the returnTo query parameter's value is not added to the Location header when it starts with www")
    void
            test_That_ReturnToQueryParameterValue_IsNotAddedToLocationHeader_WhenItStartsWith_WWW_Level5() {
        try {
            String redirectUrl = "www.somedomain.com";
            RequestEntity<String> requestEntity =
                    new RequestEntity<>(
                            HttpMethod.GET,
                            new URI("https://somedomain.com?returnTo=www.somedomain.com"));
            ResponseEntity<?> responseEntity =
                    http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel5(
                            requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY)).isEqualTo(null);
            verify(http3xxStatusCodeBasedInjection, times(1))
                    .getVulnerablePayloadLevel5(requestEntity, "www.somedomain.com");
        } catch (URISyntaxException | MalformedURLException exception) {
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName(
            "Level 5- test that the returnTo query parameter's value is not added to the Location header when it starts with //")
    void
            test_That_ReturnToQueryParameterValue_IsNotAddedToLocationHeader_WhenItStartsWith_DoubleSlash_Level5() {
        try {
            String redirectUrl = "//www.somedomain.com";
            RequestEntity<String> requestEntity =
                    new RequestEntity<>(
                            HttpMethod.GET,
                            new URI("https://somedomain.com?returnTo=//www.somedomain.com"));
            ResponseEntity<?> responseEntity =
                    http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel5(
                            requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY)).isEqualTo(null);
            verify(http3xxStatusCodeBasedInjection, times(1))
                    .getVulnerablePayloadLevel5(requestEntity, "//www.somedomain.com");
        } catch (URISyntaxException | MalformedURLException exception) {
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName(
            "Level 5- test that the returnTo query parameter's value is not added to the Location header when it starts with null byte character")
    void
            test_That_ReturnToQueryParameterValue_IsNotAddedToLocationHeader_WhenItStartsWith_NullByteCharacter_Level5() {
        try {
            String redirectUrl = (char) 0 + "//www.somedomain.com";
            RequestEntity<String> requestEntity =
                    new RequestEntity<>(
                            HttpMethod.GET,
                            new URI(
                                    "https://somedomain.com?returnTo=//"
                                            + (char) 0
                                            + "www.somedomain.com"));
            ResponseEntity<?> responseEntity =
                    http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel5(
                            requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY)).isEqualTo(null);
            verify(http3xxStatusCodeBasedInjection, times(1))
                    .getVulnerablePayloadLevel5(requestEntity, (char) 0 + "//www.somedomain.com");
        } catch (URISyntaxException | MalformedURLException exception) {
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName(
            "Level 5- test that the returnTo query parameter's value is not added to the Location header when it is an empty string")
    void
            test_That_ReturnToQueryParameterValue_IsNotAddedToLocationHeader_WhenItIsAn_EmptyString_Level5() {
        try {
            String redirectUrl = "";
            RequestEntity<String> requestEntity =
                    new RequestEntity<>(
                            HttpMethod.GET, new URI("https://somedomain.com?returnTo="));
            ResponseEntity<?> responseEntity =
                    http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel5(
                            requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY)).isEqualTo(null);
            verify(http3xxStatusCodeBasedInjection, times(1))
                    .getVulnerablePayloadLevel5(requestEntity, "");
        } catch (URISyntaxException | MalformedURLException exception) {
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName(
            "Level 5- test that the returnTo query parameter's value is added to the Location header when it does not start with https, http, www, //, or null byte character")
    void
            test_That_ReturnToQueryParameterValue_IsAddedToLocationHeader_WhenItDoesNotStartWith_Http_Https_DoubleSlashes_Null_Byte_Character_Or_WWW_Level5() {
        try {
            String redirectUrl = "\\/\\/localdomain.pw/";
            RequestEntity<String> requestEntity =
                    new RequestEntity<>(
                            HttpMethod.GET,
                            new URI("https://somedomain.com:8080?returnTo=\\/\\/localdomain.pw/"));
            ResponseEntity<?> responseEntity =
                    http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel5(
                            requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.FOUND);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY))
                    .contains("\\/\\/localdomain.pw/");
            verify(http3xxStatusCodeBasedInjection, times(1))
                    .getVulnerablePayloadLevel5(requestEntity, "\\/\\/localdomain.pw/");
        } catch (URISyntaxException | MalformedURLException exception) {
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName(
            "Level 5- test that the returnTo query parameter's value is directly added to the Location header when it is the same as the application domain")
    void
            test_That_ReturnToQueryParameterValue_IsAddedToLocationHeader_WhenItIsSameAs_ApplicationDomain_Level5() {
        try {
            String redirectUrl = "somedomain.com";
            RequestEntity<String> requestEntity =
                    new RequestEntity<>(
                            HttpMethod.GET,
                            new URI("https://somedomain.com?returnTo=somedomain.com"));
            ResponseEntity<?> responseEntity =
                    http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel5(
                            requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.FOUND);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY))
                    .contains("somedomain.com");
            verify(http3xxStatusCodeBasedInjection, times(1))
                    .getVulnerablePayloadLevel5(requestEntity, "somedomain.com");
        } catch (URISyntaxException | MalformedURLException exception) {
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName(
            "Level 6- test that the returnTo query parameter's value is directly added to the Location header by adding domain as prefix")
    void
            test_That_ReturnToQueryParameterValue_IsAddedToLocationHeader_ByAddingDomainToPrefix_Level6() {
        try {
            String redirectUrl = "somedomain.com";
            RequestEntity<String> requestEntity =
                    new RequestEntity<>(
                            HttpMethod.GET,
                            new URI("https://somedomain.com?returnTo=somedomain.com"));
            ResponseEntity<?> responseEntity =
                    http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel6(
                            requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.FOUND);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY))
                    .contains("https://somedomain.comsomedomain.com");
            verify(http3xxStatusCodeBasedInjection, times(1))
                    .getVulnerablePayloadLevel6(requestEntity, "somedomain.com");
        } catch (URISyntaxException | MalformedURLException exception) {
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName(
            "Level 7- test that the returnTo query parameter's value is directly added to the Location header by adding domain as prefix")
    void
            test_That_ReturnToQueryParameterValue_IsAddedToLocationHeader_ByAddingDomainToPrefix_Level7() {
        try {
            String redirectUrl = "/somedomain.com";
            RequestEntity<String> requestEntity =
                    new RequestEntity<>(
                            HttpMethod.GET,
                            new URI("https://somedomain.com?returnTo=/somedomain.com"));
            ResponseEntity<?> responseEntity =
                    http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel7(
                            requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.FOUND);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY))
                    .contains("https://somedomain.com/somedomain.com");
            verify(http3xxStatusCodeBasedInjection, times(1))
                    .getVulnerablePayloadLevel7(requestEntity, "/somedomain.com");
        } catch (URISyntaxException | MalformedURLException exception) {
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName(
            "Level 8- test that the returnTo query parameter's value is not added to the Location header when it is not in the list of whitelisted URLS")
    void
            test_That_ReturnToQueryParameterValue_IsNotAddedToLocationHeader_WhenItIsNotInTheListOfWhiteListedURLS_Level8() {
        try {
            // /somedomain.com is not in the list of whitelisted urls
            String redirectUrl = "/somedomain.com";
            RequestEntity<String> requestEntity =
                    new RequestEntity<>(
                            HttpMethod.GET,
                            new URI("https://somedomain.com?returnTo=/somedomain.com"));
            ResponseEntity<?> responseEntity =
                    http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel8(
                            requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY)).isEqualTo(null);
            verify(http3xxStatusCodeBasedInjection, times(1))
                    .getVulnerablePayloadLevel8(requestEntity, "/somedomain.com");
        } catch (URISyntaxException exception) {
            exception.printStackTrace();
        }
    }

    @Test
    @DisplayName(
            "Level 8- test that the returnTo query parameter's value is not added to the Location header when it is not in the list of whitelisted URLS")
    void
            test_That_ReturnToQueryParameterValue_IsAddedToLocationHeader_WhenItIsInTheListOfWhiteListedURLS_Level8() {
        try {
            String redirectUrl = "/";
            RequestEntity<String> requestEntity =
                    new RequestEntity<>(
                            HttpMethod.GET,
                            new URI("https://somedomain.com?returnTo=/somedomain.com"));
            ResponseEntity<?> responseEntity =
                    http3xxStatusCodeBasedInjection.getVulnerablePayloadLevel8(
                            requestEntity, redirectUrl);
            assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.FOUND);
            assertThat(responseEntity.getHeaders().get(LOCATION_HEADER_KEY)).contains("/");
            verify(http3xxStatusCodeBasedInjection, times(1))
                    .getVulnerablePayloadLevel8(requestEntity, "/");
        } catch (URISyntaxException exception) {
            exception.printStackTrace();
        }
    }
}
